"use strict";
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.specUrl = exports.specsFromOpts = void 0;
const path = __importStar(require("path"));
const browser_1 = require("./browser");
const config_1 = require("./config");
const defaults = __importStar(require("./defaults"));
const util_1 = require("./util");
const versions_1 = require("./versions");
/**
 * Derive the set of benchmark specifications we should run according to the
 * given options, which may require checking the layout on disk of the
 * benchmarks/ directory.
 */
async function specsFromOpts(opts) {
    let windowSize;
    if (opts['window-size']) {
        const match = opts['window-size'].match(/^(\d+),(\d+)$/);
        if (match === null) {
            throw new Error(`Invalid --window-size flag, must match "width,height, " ` +
                `but was "${opts['window-size']}"`);
        }
        windowSize = {
            width: Number(match[1]),
            height: Number(match[2]),
        };
    }
    else {
        windowSize = {
            width: defaults.windowWidth,
            height: defaults.windowHeight,
        };
    }
    let trace;
    if (opts['trace']) {
        const rawLogDir = opts['trace-log-dir'];
        trace = {
            categories: opts['trace-cat'].split(','),
            logDir: path.isAbsolute(rawLogDir)
                ? rawLogDir
                : path.join(process.cwd(), rawLogDir),
        };
    }
    const browserStrings = new Set((opts.browser || defaults.browserName)
        .replace(/\s+/, '')
        .split(',')
        .filter((b) => b !== ''));
    if (browserStrings.size === 0) {
        throw new Error('At least one --browser must be specified');
    }
    const browsers = [...browserStrings].map((str) => {
        const config = Object.assign(Object.assign({}, (0, browser_1.parseBrowserConfigString)(str)), { windowSize });
        if (trace) {
            config.trace = trace;
        }
        (0, browser_1.validateBrowserConfig)(config);
        return config;
    });
    const specs = [];
    const versions = (0, versions_1.parsePackageVersions)(opts['package-version']);
    if (versions.length === 0) {
        versions.push(undefined);
    }
    let measurement;
    if (opts.measure === 'callback') {
        measurement = {
            mode: 'callback',
        };
    }
    else if (opts.measure === 'fcp') {
        measurement = {
            mode: 'performance',
            entryName: 'first-contentful-paint',
        };
    }
    else if (opts.measure === 'global') {
        measurement = {
            mode: 'expression',
            expression: opts['measurement-expression'] || defaults.measurementExpression,
        };
    }
    else if (opts.measure !== undefined) {
        (0, util_1.throwUnreachable)(opts.measure, `Internal error: unknown measure ${JSON.stringify(opts.measure)}`);
    }
    // Benchmark paths/URLs are the bare arguments not associated with a flag, so
    // they are found in _unknown.
    for (const argStr of opts._unknown || []) {
        const arg = parseBenchmarkArgument(argStr);
        if (arg.kind === 'remote') {
            const url = {
                kind: 'remote',
                url: arg.url,
            };
            for (const browser of browsers) {
                const spec = {
                    name: arg.alias || arg.url,
                    browser,
                    measurement: [
                        measurement === undefined ? defaults.measurement(url) : measurement,
                    ],
                    url,
                };
                specs.push(spec);
            }
        }
        else {
            const root = opts.root || defaults.root;
            const urlPath = await (0, config_1.urlFromLocalPath)(root, arg.diskPath);
            let name = arg.alias;
            if (name === undefined) {
                const serverRelativePath = path.relative(root, arg.diskPath);
                name = serverRelativePath.replace(/\\/g, '/');
            }
            for (const browser of browsers) {
                for (const version of versions) {
                    const url = {
                        kind: 'local',
                        urlPath,
                        queryString: arg.queryString,
                        version,
                    };
                    const spec = {
                        name,
                        browser,
                        measurement: [
                            measurement === undefined
                                ? defaults.measurement(url)
                                : measurement,
                        ],
                        url,
                    };
                    specs.push(spec);
                }
            }
        }
    }
    return specs;
}
exports.specsFromOpts = specsFromOpts;
function parseBenchmarkArgument(str) {
    if ((0, util_1.isHttpUrl)(str)) {
        // http://example.com
        return {
            kind: 'remote',
            url: str,
        };
    }
    if (str.includes('=')) {
        const eq = str.indexOf('=');
        const maybeUrl = str.substring(eq + 1);
        if ((0, util_1.isHttpUrl)(maybeUrl)) {
            // foo=http://example.com
            return {
                kind: 'remote',
                url: maybeUrl,
                alias: str.substring(0, eq),
            };
        }
    }
    let queryString = '';
    if (str.includes('?')) {
        // a/b.html?a=b
        // foo=a/b.html?a=b
        const q = str.indexOf('?');
        queryString = str.substring(q);
        str = str.substring(0, q);
    }
    let alias = undefined;
    if (str.includes('=')) {
        // foo=a/b.html?a=b
        // foo=a/b.html
        const eq = str.indexOf('=');
        alias = str.substring(0, eq);
        str = str.substring(eq + 1);
    }
    // a/b.html
    // a/b.html?a=b
    // foo=a/b.html
    // foo=a/b.html?a=b
    return {
        kind: 'local',
        alias,
        diskPath: str,
        queryString: queryString,
    };
}
function specUrl(spec, servers, config) {
    if (spec.url.kind === 'remote') {
        return spec.url.url;
    }
    const server = servers.get(spec);
    if (server === undefined) {
        throw new Error('Internal error: no server for spec');
    }
    if (config.remoteAccessibleHost !== '' &&
        spec.browser.remoteUrl !== undefined) {
        return ('http://' +
            config.remoteAccessibleHost +
            ':' +
            server.port +
            spec.url.urlPath +
            spec.url.queryString);
    }
    return server.url + spec.url.urlPath + spec.url.queryString;
}
exports.specUrl = specUrl;
//# sourceMappingURL=specs.js.map