"use strict";
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const http = __importStar(require("http"));
const path = __importStar(require("path"));
const Koa = require("koa");
const mount = require("koa-mount");
const send = require("koa-send");
const getStream = require("get-stream");
const serve = require("koa-static");
const bodyParser = require("koa-bodyparser");
const koa_node_resolve_1 = require("koa-node-resolve");
const types_1 = require("./types");
const clientLib = path.resolve(__dirname, '..', 'client', 'lib');
class Server {
    constructor(server, opts) {
        this.session = { bytesSent: 0, userAgent: '' };
        this.deferredResults = new types_1.Deferred();
        this.urlCache = new Map();
        this.server = server;
        const app = new Koa();
        app.use(bodyParser());
        app.use(mount('/submitResults', this.submitResults.bind(this)));
        app.use(this.instrumentRequests.bind(this));
        if (opts.cache) {
            app.use(this.cache.bind(this));
        }
        app.use(this.serveBenchLib.bind(this));
        if (opts.resolveBareModules === true) {
            const npmRoot = opts.npmInstalls.length > 0
                ? opts.npmInstalls[0].installDir
                : opts.root;
            app.use((0, koa_node_resolve_1.nodeResolve)({
                root: npmRoot,
                // TODO Use default logging options after issues resolved:
                // https://github.com/Polymer/koa-node-resolve/issues/16
                // https://github.com/Polymer/koa-node-resolve/issues/17
                logger: false,
            }));
        }
        for (const { diskPath, urlPath } of opts.mountPoints) {
            app.use(mount(urlPath, serve(diskPath, { index: 'index.html' })));
        }
        this.server.on('request', app.callback());
        const address = this.server.address();
        let host = address.address;
        if (address.family === 'IPv6') {
            host = `[${host}]`;
        }
        this.port = address.port;
        this.url = `http://${host}:${this.port}`;
    }
    static start(opts) {
        const server = http.createServer();
        const ports = [...opts.ports];
        return new Promise((resolve, reject) => {
            const tryNextPort = () => {
                if (ports.length === 0) {
                    reject(`No ports available, tried: ${opts.ports.join(', ')}`);
                }
                else {
                    server.listen({ host: opts.host, port: ports.shift() });
                }
            };
            server.on('listening', () => resolve(new Server(server, opts)));
            server.on('error', (e) => {
                if (e.code === 'EADDRINUSE' || e.code === 'EACCES') {
                    tryNextPort();
                }
                else {
                    reject(e);
                }
            });
            tryNextPort();
        });
    }
    /**
     * Mark the end of one session, return the data instrumented from it, and
     * begin a new session.
     */
    endSession() {
        const session = this.session;
        this.session = { bytesSent: 0, userAgent: '' };
        this.deferredResults = new types_1.Deferred();
        return session;
    }
    async nextResults() {
        return this.deferredResults.promise;
    }
    async close() {
        return new Promise((resolve, reject) => {
            this.server.close((error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    async instrumentRequests(ctx, next) {
        var _a;
        const session = this.session;
        if (session === undefined) {
            return next();
        }
        session.userAgent = (_a = ctx.headers['user-agent']) !== null && _a !== void 0 ? _a : '';
        // Note this assumes serial runs, as we guarantee in automatic mode.
        // If we ever wanted to support parallel requests, we would require
        // some kind of session tracking.
        await next();
        if (typeof ctx.response.length === 'number') {
            session.bytesSent += ctx.response.length;
        }
        else if (ctx.status === 200) {
            console.log(`No response length for 200 response for ${ctx.url}, ` +
                `byte count may be inaccurate.`);
        }
    }
    /**
     * Cache all downstream middleware responses by URL in memory. This is
     * especially helpful when bare module resolution is enabled, because that
     * requires expensive parsing of all HTML and JavaScript that we really don't
     * want to do for every benchmark sample.
     */
    async cache(ctx, next) {
        const entry = this.urlCache.get(ctx.url);
        if (entry !== undefined) {
            ctx.response.set(entry.headers);
            ctx.response.body = entry.body;
            // Note we must set status after we set body, because when we set body to
            // undefined (which happens on e.g. 404s), Koa overrides the status to
            // 204.
            ctx.response.status = entry.status;
            return;
        }
        await next();
        const body = ctx.response.body;
        let bodyString;
        if (typeof body === 'string') {
            bodyString = body;
        }
        else if (Buffer.isBuffer(body)) {
            bodyString = body.toString();
        }
        else if (isStream(body)) {
            bodyString = await getStream(body);
            // We consumed the stream.
            ctx.response.body = bodyString;
        }
        else if (body === null || body === undefined) {
            // The static middleware sets no body for errors. Koa automatically
            // creates a body for errors later. Just cache as-is so that the same
            // thing happens on cache hits.
            bodyString = body;
        }
        else {
            throw new Error(`Unknown response type ${typeof body} for ${ctx.url}`);
        }
        this.urlCache.set(ctx.url, {
            body: bodyString,
            status: ctx.response.status,
            headers: ctx.response.headers,
        });
    }
    async serveBenchLib(ctx, next) {
        if (ctx.path === '/bench.js') {
            await send(ctx, 'bench.js', { root: clientLib });
        }
        else {
            await next();
        }
    }
    async submitResults(ctx) {
        this.deferredResults.resolve(ctx.request.body);
        ctx.body = 'ok';
    }
}
exports.Server = Server;
function isStream(value) {
    return (value !== null &&
        typeof value === 'object' &&
        typeof value.pipe === 'function');
}
//# sourceMappingURL=server.js.map