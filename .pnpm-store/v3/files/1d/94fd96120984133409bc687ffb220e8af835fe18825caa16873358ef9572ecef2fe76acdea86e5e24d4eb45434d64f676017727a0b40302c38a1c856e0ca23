"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = previewer;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _unistUtilVisit() {
  const data = _interopRequireDefault(require("unist-util-visit"));

  _unistUtilVisit = function _unistUtilVisit() {
    return data;
  };

  return data;
}

function _slash() {
  const data = _interopRequireDefault(require("slash2"));

  _slash = function _slash() {
    return data;
  };

  return data;
}

var _context = _interopRequireDefault(require("../../context"));

var _demo = _interopRequireWildcard(require("../demo"));

var _ = _interopRequireDefault(require(".."));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const demoIds = {};
/**
 * get unique id for previewer
 * @param yaml          meta data
 * @param fileAbsPath   file absolute path
 * @param componentName the name of related component
 */

function getPreviewerId(yaml, fileAbsPath, componentName) {
  const ids = demoIds[fileAbsPath];
  let id = yaml.identifier || yaml.uuid || componentName; // do not generate identifier for inline demo

  if (yaml.inline) {
    return;
  }

  if (!id) {
    // /path/to/md => path-to-md
    id = (0, _slash().default)(fileAbsPath) // discard suffix like index.md
    .replace(/(?:\/index)?(\.[\w-]+)?\.\w+$/, '$1').split(/\/|\./) // get the last three levels
    .slice(-2).join('-').toLowerCase();
  } // record id


  ids[id] = (ids[id] || 0) + 1; // handle conflict ids

  return ids[id] > 1 ? `${id}-${ids[id] - 1}` : id;
}
/**
 * transform previewer node to code, dependent fies & dependencies
 * @param node        previewer node
 * @param fileAbsPath demo absolute path
 */


function transformNode(node, fileAbsPath) {
  const props = node.properties;
  const code = props.source.tsx || props.source.jsx;
  const isExternalDemo = props.filePath;
  const transformOpts = {
    isTSX: Boolean(props.source.tsx),
    fileAbsPath
  };
  return _objectSpread({
    code: (0, _demo.default)( // use import way for external demo use to HMR & sourcemap
    isExternalDemo ? `
import React from 'react';
import Demo from '${props.filePath}';

export default () => <Demo />;
` : code, transformOpts).content
  }, (0, _demo.getDepsForDemo)(code, transformOpts));
}
/**
 * apply code block detecting event
 * @param props previewer props
 * @param componentName the name of related component
 */


function applyCodeBlock(props, componentName) {
  var _ctx$umi;

  (_ctx$umi = _context.default.umi) === null || _ctx$umi === void 0 ? void 0 : _ctx$umi.applyPlugins({
    key: 'dumi.detectCodeBlock',
    type: _context.default.umi.ApplyPluginsType.event,
    args: {
      type: 'BLOCK',
      name: props.title,
      description: props.description,
      thumbnail: props.thumbnail,
      tags: props.tags,
      atomAssetId: componentName,
      // for HiTu DSM
      uuid: props.uuid,
      dependencies: _objectSpread(_objectSpread({}, Object.entries(props.dependencies).reduce((deps, [pkg, {
        version
      }]) => Object.assign(deps, {
        [pkg]: {
          type: 'NPM',
          // TODO: get real version rule from package.json
          value: version
        }
      }), {})), Object.entries(props.sources).reduce((result, [file, {
        tsx,
        jsx,
        content
      }]) => Object.assign(result, {
        // handle main file
        [file === '_' ? `index.${tsx ? 'tsx' : 'jsx'}` : file]: {
          type: 'FILE',
          value: tsx || jsx || content
        }
      }), {}))
    }
  });
}
/**
 * apply demo detecting event
 * @param props previewer props
 */


function applyDemo(props, code) {
  var _ctx$umi2;

  (_ctx$umi2 = _context.default.umi) === null || _ctx$umi2 === void 0 ? void 0 : _ctx$umi2.applyPlugins({
    key: 'dumi.detectDemo',
    type: _context.default.umi.ApplyPluginsType.event,
    args: {
      uuid: props.identifier,
      code,
      previewerProps: props
    }
  });
}

function visitor(node, i, parent) {
  var _node$properties;

  if (node.tagName === 'div' && ((_node$properties = node.properties) === null || _node$properties === void 0 ? void 0 : _node$properties.type) === 'previewer') {
    var _this$vFile$data$demo;

    const source = node.properties.source;
    const yaml = node.properties.meta || {};
    const fileAbsPath = // for external demo
    node.properties.filePath || // for embed demo
    this.data('fileAbsPath');
    Object.keys(yaml).forEach(oKey => {
      // workaround for JSX prop name not allowed to contains .
      // refer: https://github.com/facebook/jsx/issues/42
      let key = oKey.replace(/\./g, '_');
      const matched = key.match(/^desc(?:(_[\w-]+$)|$)/); // compatible with short-hand usage for description field in previous dumi versions

      if (matched) {
        key = `description${matched[1] || ''}`;
      } // replace props key name


      if (key !== oKey) {
        yaml[key] = yaml[oKey];
        delete yaml[oKey];
      } // transform markdown for description field


      if (/^description(_|$)/.test(key)) {
        // use wrapper object for workaround to avoid escape \n
        // eslint-disable-next-line
        yaml[key] = new String(JSON.stringify(_.default.markdown(yaml[key], null, {
          type: 'html'
        }).content));
      }
    }); // transform demo node

    const _transformNode = transformNode(node, fileAbsPath),
          code = _transformNode.code,
          dependencies = _transformNode.dependencies,
          files = _transformNode.files; // create properties for Previewer


    const previewerProps = _objectSpread(_objectSpread({
      sources: _objectSpread({
        _: source
      }, Object.keys(files).reduce((result, file) => _objectSpread(_objectSpread({}, result), {}, {
        [file]: {
          import: files[file].import,
          content: files[file].content
        }
      }), {})),
      dependencies,
      componentName: this.vFile.data.componentName
    }, yaml), {}, {
      // to avoid user's identifier override internal logic
      identifier: getPreviewerId(yaml, this.data('fileAbsPath'), this.vFile.data.componentName)
    }); // declare demo on the top page component for memo


    const demoComponentCode = yaml.inline ? // insert directly for inline demo
    `React.memo(${code})` : // render other demo from the common demo module: @@/dumi/demos
    `require('@@/dumi/demos').default['${previewerProps.identifier}'].component`;
    this.vFile.data.demos = (this.vFile.data.demos || []).concat(`const ${_demo.DEMO_COMPONENT_NAME}${(((_this$vFile$data$demo = this.vFile.data.demos) === null || _this$vFile$data$demo === void 0 ? void 0 : _this$vFile$data$demo.length) || 0) + 1} = ${demoComponentCode};`); // replace original node

    if (yaml.inline) {
      parent.children[i] = {
        previewer: true,
        type: 'element',
        tagName: `${_demo.DEMO_COMPONENT_NAME}${this.vFile.data.demos.length}`
      };
    } else {
      // apply umi plugins
      applyCodeBlock(previewerProps, this.vFile.data.componentName);
      applyDemo(previewerProps, code);
      parent.children[i] = {
        previewer: true,
        type: 'element',
        tagName: 'Previewer',
        // TODO: read props from common @@/dumi/demos module to reduce bundle size
        properties: previewerProps,
        children: [{
          type: 'element',
          tagName: `${_demo.DEMO_COMPONENT_NAME}${this.vFile.data.demos.length}`,
          properties: {}
        }]
      };
    }
  }
}

function previewer() {
  // clear single paths for a new transform flow
  if (this.data('fileAbsPath')) {
    demoIds[this.data('fileAbsPath')] = {};
  }

  return (ast, vFile) => {
    (0, _unistUtilVisit().default)(ast, 'element', visitor.bind({
      vFile,
      data: this.data
    }));
  };
}