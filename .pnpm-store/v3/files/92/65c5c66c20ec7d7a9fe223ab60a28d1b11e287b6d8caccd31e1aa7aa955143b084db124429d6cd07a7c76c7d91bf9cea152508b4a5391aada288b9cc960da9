"use strict";
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatCsvRaw = exports.formatCsvStats = void 0;
const sync_1 = __importDefault(require("csv-stringify/lib/sync"));
const precision = 5;
/**
 * Format statistical results as a CSV file string.
 */
function formatCsvStats(results) {
    // Note the examples in ./test/csv_test.ts should make this easier to
    // understand.
    const h1 = ['', '', ''];
    const h2 = ['', 'ms', ''];
    const h3 = ['', 'min', 'max'];
    const rows = [];
    for (const result of results) {
        h1.push(`vs ${result.result.name}`, '', '', '');
        h2.push('% change', '', 'ms change', '');
        h3.push('min', 'max', 'min', 'max');
        const row = [];
        row.push(result.result.name, result.stats.meanCI.low.toFixed(precision), result.stats.meanCI.high.toFixed(precision));
        for (const diff of result.differences) {
            if (diff === null) {
                row.push('', '', '', '');
            }
            else {
                row.push((diff.relative.low * 100).toFixed(precision) + '%', (diff.relative.high * 100).toFixed(precision) + '%', diff.absolute.low.toFixed(precision), diff.absolute.high.toFixed(precision));
            }
        }
        rows.push(row);
    }
    return (0, sync_1.default)([h1, h2, h3, ...rows]);
}
exports.formatCsvStats = formatCsvStats;
/**
 * Format raw sample results as a CSV file string.
 *
 * Columns correspond to benchmarks. Rows correspond to sample iterations. The
 * first row is headers containing the benchmark names.
 *
 * For example:
 *
 * foo, bar, baz
 * 1.2, 5.5, 9.4
 * 1.8, 5.6, 9.1
 * 1.3, 5.2, 9.8
 */
function formatCsvRaw(results) {
    const headers = [];
    const rows = [];
    for (let r = 0; r < results.length; r++) {
        const { result } = results[r];
        headers.push(result.name);
        for (let m = 0; m < result.millis.length; m++) {
            if (rows[m] === undefined) {
                rows[m] = [];
            }
            rows[m][r] = result.millis[m];
        }
    }
    return (0, sync_1.default)([headers, ...rows]);
}
exports.formatCsvRaw = formatCsvRaw;
//# sourceMappingURL=csv.js.map